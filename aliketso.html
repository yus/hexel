<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TSO Hex Grid Foundation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            background: #1a1a1a;
            font-family: 'Segoe UI', system-ui, monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #grid-canvas {
            background: #111;
            z-index: 1;
            pointer-events: none; /* Grid doesn't block interaction */
        }
        
        #draw-canvas {
            background: transparent;
            z-index: 2;
            pointer-events: auto; /* Your drawing surface */
        }
        
        #ui-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 40, 0.85);
            backdrop-filter: blur(10px);
            color: #e2e2e2;
            padding: 14px 24px;
            border-radius: 100px;
            border: 1px solid rgba(180, 140, 255, 0.3);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 10;
            display: flex;
            gap: 24px;
            font-size: 15px;
            letter-spacing: 0.3px;
        }
        
        #ui-panel button {
            background: rgba(180, 140, 255, 0.2);
            border: 1px solid rgba(180, 140, 255, 0.5);
            color: #c4b5fd;
            padding: 6px 16px;
            border-radius: 40px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        #ui-panel button:hover {
            background: rgba(180, 140, 255, 0.4);
            color: white;
            border-color: #c4b5fd;
        }
        
        #ui-panel button.active {
            background: #c4b5fd;
            color: #111;
            border-color: #c4b5fd;
        }
        
        #coords {
            display: flex;
            align-items: center;
            gap: 16px;
            color: #aaa;
        }
        
        #coords span {
            color: #c4b5fd;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }
        
        #status {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(30, 30, 40, 0.7);
            backdrop-filter: blur(8px);
            padding: 8px 18px;
            border-radius: 40px;
            color: #c4b5fd;
            font-size: 13px;
            border: 1px solid rgba(180, 140, 255, 0.3);
            z-index: 10;
            display: flex;
            gap: 16px;
        }
        
        #instructions {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(30, 30, 40, 0.5);
            backdrop-filter: blur(4px);
            padding: 8px 16px;
            border-radius: 40px;
            color: #888;
            font-size: 12px;
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        @media (max-width: 700px) {
            #ui-panel {
                flex-wrap: wrap;
                width: 90%;
                border-radius: 30px;
                bottom: 16px;
                padding: 12px 16px;
            }
            #coords {
                order: 3;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="grid-canvas"></canvas>
        <canvas id="draw-canvas"></canvas>
    </div>
    
    <div id="ui-panel">
        <div style="display: flex; gap: 12px;">
            <button id="toggle-grid" class="active">‚¨ü GRID ON</button>
            <button id="clear-draw">üóëÔ∏è CLEAR</button>
        </div>
        
        <div id="coords">
            <div>üìç <span id="coord-x">0.00</span>, <span id="coord-y">0.00</span></div>
            <div>üîç <span id="zoom-level">1.00</span>x</div>
        </div>
        
        <div style="color: #c4b5fd80; font-size: 13px;">
            <span>‚ö° drag ¬∑ pinch ¬∑ scroll</span>
        </div>
    </div>
    
    <div id="status">
        <span>üìê TSO HEX GRID</span>
        <span>‚¨ü <span id="grid-size">48</span>px</span>
    </div>
    
    <div id="instructions">
        DRAW ON CANVAS ‚Äî CLICK TO PAINT DOTS
    </div>

    <script>
        (function() {
            // === CANVAS SETUP ===
            const gridCanvas = document.getElementById('grid-canvas');
            const drawCanvas = document.getElementById('draw-canvas');
            const gridCtx = gridCanvas.getContext('2d');
            const drawCtx = drawCanvas.getContext('2d');
            
            // === GRID PARAMETERS ===
            const BASE_SIZE = 24; // base triangle side
            const H_STEP = BASE_SIZE * 2;        // 48px horizontal spacing
            const V_STEP = BASE_SIZE * Math.sqrt(3); // ~41.57px vertical
            
            // === VIEW STATE ===
            let scale = 1.0;
            let offsetX = 0;
            let offsetY = 0;
            
            // === GRID STATE ===
            let gridEnabled = true;
            
            // === DRAWING STATE ===
            let drawings = []; // store your polygons/dots
            
            // === INTERACTION ===
            let isDragging = false;
            let lastX, lastY;
            let lastDistance = 0;
            
            // === RESIZE HANDLER ===
            function resizeCanvases() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                gridCanvas.width = width;
                gridCanvas.height = height;
                drawCanvas.width = width;
                drawCanvas.height = height;
                
                // Redraw everything
                drawGrid();
                drawDrawings();
            }
            
            // === SNAP TO NEAREST HEX INTERSECTION ===
            function snapToGrid(screenX, screenY) {
                const centerX = gridCanvas.width / 2 + offsetX;
                const centerY = gridCanvas.height / 2 + offsetY;
                
                const scaledH = H_STEP * scale;
                const scaledV = V_STEP * scale;
                
                // Convert to grid coordinates
                const gridX = (screenX - centerX) / scaledH;
                const gridY = (screenY - centerY) / scaledV;
                
                // Find nearest row
                const row = Math.round(gridY);
                
                // Find nearest col based on row parity
                let col;
                let worldX, worldY;
                
                if (row % 2 !== 0) {
                    // Odd row - offset by half
                    const exactX = gridX - 0.5;
                    col = Math.round(exactX);
                    worldX = (col + 0.5) * H_STEP;
                    worldY = row * V_STEP;
                } else {
                    // Even row
                    col = Math.round(gridX);
                    worldX = col * H_STEP;
                    worldY = row * V_STEP;
                }
                
                return {
                    worldX, worldY,
                    screenX: centerX + (row % 2 !== 0 ? (col + 0.5) * scaledH : col * scaledH),
                    screenY: centerY + row * scaledV
                };
            }
            
            // === GRID DRAWING ===
            function drawGrid() {
                gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
                
                if (!gridEnabled) return;
                
                const centerX = gridCanvas.width / 2 + offsetX;
                const centerY = gridCanvas.height / 2 + offsetY;
                
                const scaledH = H_STEP * scale;
                const scaledV = V_STEP * scale;
                
                // Calculate visible range
                const cols = Math.ceil(gridCanvas.width / scaledH) + 8;
                const rows = Math.ceil(gridCanvas.height / scaledV) + 8;
                
                const startCol = -Math.floor(cols / 2) - 2;
                const startRow = -Math.floor(rows / 2) - 2;
                const endCol = startCol + cols + 4;
                const endRow = startRow + rows + 4;
                
                // Update UI
                document.getElementById('coord-x').textContent = (-offsetX / (H_STEP * scale) * H_STEP).toFixed(2);
                document.getElementById('coord-y').textContent = (-offsetY / (V_STEP * scale) * V_STEP).toFixed(2);
                document.getElementById('zoom-level').textContent = scale.toFixed(2);
                document.getElementById('grid-size').textContent = Math.round(BASE_SIZE * scale);
                
                // HAIRLINE THIN
                gridCtx.lineWidth = Math.max(0.5, 1.0 / Math.sqrt(scale));
                gridCtx.strokeStyle = '#b388ff';
                
                // HORIZONTAL LINES
                gridCtx.globalAlpha = 0.25;
                gridCtx.beginPath();
                for (let row = startRow; row <= endRow; row++) {
                    const y = centerY + row * scaledV;
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(gridCanvas.width, y);
                }
                gridCtx.stroke();
                
                // +60¬∞ DIAGONALS
                gridCtx.beginPath();
                for (let row = startRow - 3; row <= endRow + 3; row++) {
                    for (let col = startCol - 3; col <= endCol + 3; col++) {
                        const x = centerX + col * scaledH;
                        const y = centerY + row * scaledV;
                        const xOffset = (row % 2 === 0) ? 0 : scaledH / 2;
                        
                        const extend = Math.max(gridCanvas.width, gridCanvas.height);
                        gridCtx.moveTo(x + xOffset - extend, y - extend * Math.tan(60 * Math.PI / 180));
                        gridCtx.lineTo(x + xOffset + extend, y + extend * Math.tan(60 * Math.PI / 180));
                    }
                }
                gridCtx.stroke();
                
                // -60¬∞ DIAGONALS
                gridCtx.beginPath();
                for (let row = startRow - 3; row <= endRow + 3; row++) {
                    for (let col = startCol - 3; col <= endCol + 3; col++) {
                        const x = centerX + col * scaledH;
                        const y = centerY + row * scaledV;
                        const xOffset = (row % 2 === 0) ? 0 : scaledH / 2;
                        
                        const extend = Math.max(gridCanvas.width, gridCanvas.height);
                        gridCtx.moveTo(x + xOffset - extend, y + extend * Math.tan(60 * Math.PI / 180));
                        gridCtx.lineTo(x + xOffset + extend, y - extend * Math.tan(60 * Math.PI / 180));
                    }
                }
                gridCtx.stroke();
                
                // INTERSECTION DOTS
                gridCtx.fillStyle = '#b388ff';
                gridCtx.globalAlpha = 0.3;
                for (let row = startRow; row <= endRow; row++) {
                    for (let col = startCol; col <= endCol; col++) {
                        const x = centerX + col * scaledH;
                        const y = centerY + row * scaledV;
                        
                        if (row % 2 !== 0) {
                            gridCtx.beginPath();
                            gridCtx.arc(x + scaledH/2, y, 1.2, 0, Math.PI*2);
                            gridCtx.fill();
                        } else {
                            gridCtx.beginPath();
                            gridCtx.arc(x, y, 1.2, 0, Math.PI*2);
                            gridCtx.fill();
                        }
                    }
                }
                
                // ORIGIN MARKER
                gridCtx.fillStyle = '#ffffff';
                gridCtx.globalAlpha = 0.6;
                gridCtx.beginPath();
                gridCtx.arc(centerX, centerY, 3, 0, Math.PI*2);
                gridCtx.fill();
                
                gridCtx.globalAlpha = 1.0;
            }
            
            // === DRAWING CANVAS FUNCTIONS ===
            function drawDrawings() {
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                
                // Draw all stored drawings
                drawings.forEach(point => {
                    drawCtx.fillStyle = point.color || '#ffaa66';
                    drawCtx.globalAlpha = 0.8;
                    drawCtx.beginPath();
                    drawCtx.arc(point.x, point.y, point.size || 6, 0, Math.PI*2);
                    drawCtx.fill();
                    
                    // Optional outline
                    drawCtx.strokeStyle = '#ffffff';
                    drawCtx.lineWidth = 1.5;
                    drawCtx.stroke();
                });
            }
            
            // === ADD DRAWING AT CLICK LOCATION ===
            function addDrawingAt(e) {
                e.preventDefault();
                
                const clientX = e.clientX ?? e.touches?.[0]?.clientX;
                const clientY = e.clientY ?? e.touches?.[0]?.clientY;
                
                if (!clientX || !clientY) return;
                
                const rect = drawCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                // Snap to grid if enabled
                if (gridEnabled) {
                    const snapped = snapToGrid(x, y);
                    drawings.push({
                        x: snapped.screenX,
                        y: snapped.screenY,
                        color: '#ffaa66',
                        size: 8
                    });
                } else {
                    drawings.push({
                        x, y,
                        color: '#ffaa66',
                        size: 8
                    });
                }
                
                drawDrawings();
            }
            
            // === INTERACTION HANDLERS ===
            function handleDragStart(e) {
                e.preventDefault();
                isDragging = false; // Will become true if moved > threshold
                
                const clientX = e.clientX ?? e.touches?.[0]?.clientX;
                const clientY = e.clientY ?? e.touches?.[0]?.clientY;
                
                if (!clientX) return;
                
                lastX = clientX;
                lastY = clientY;
                
                // Small timeout to differentiate click vs drag
                setTimeout(() => {
                    if (Math.abs(clientX - lastX) < 5 && Math.abs(clientY - lastY) < 5) {
                        // It's a click - add drawing
                        addDrawingAt(e);
                    }
                }, 100);
            }
            
            function handleDragMove(e) {
                e.preventDefault();
                
                const clientX = e.clientX ?? e.touches?.[0]?.clientX;
                const clientY = e.clientY ?? e.touches?.[0]?.clientY;
                
                if (!clientX || !clientY || !lastX) return;
                
                const dx = clientX - lastX;
                const dy = clientY - lastY;
                
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                    isDragging = true;
                    
                    offsetX += dx;
                    offsetY += dy;
                    
                    lastX = clientX;
                    lastY = clientY;
                    
                    // Redraw both canvases
                    drawGrid();
                    drawDrawings(); // Drawings stay in same world position
                }
            }
            
            function handleDragEnd(e) {
                e.preventDefault();
                lastX = null;
                lastY = null;
                isDragging = false;
            }
            
            // === ZOOM HANDLER ===
            function handleZoom(e) {
                e.preventDefault();
                
                const rect = gridCanvas.getBoundingClientRect();
                let clientX, clientY;
                
                if (e.touches && e.touches.length === 2) {
                    // Pinch zoom
                    const distance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    
                    if (lastDistance > 0) {
                        const zoomFactor = distance / lastDistance;
                        const prevScale = scale;
                        
                        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                        
                        const centerX = gridCanvas.width / 2 + offsetX;
                        const centerY = gridCanvas.height / 2 + offsetY;
                        
                        const worldX = (midX - centerX) / (H_STEP * prevScale);
                        const worldY = (midY - centerY) / (V_STEP * prevScale);
                        
                        scale *= zoomFactor;
                        scale = Math.max(0.2, Math.min(10, scale));
                        
                        offsetX = midX - gridCanvas.width/2 - worldX * H_STEP * scale;
                        offsetY = midY - gridCanvas.height/2 - worldY * V_STEP * scale;
                        
                        drawGrid();
                        drawDrawings();
                    }
                    lastDistance = distance;
                } else {
                    // Scroll wheel
                    clientX = e.clientX - rect.left;
                    clientY = e.clientY - rect.top;
                    
                    if (!clientX || !clientY) return;
                    
                    const centerX = gridCanvas.width / 2 + offsetX;
                    const centerY = gridCanvas.height / 2 + offsetY;
                    
                    const worldX = (clientX - centerX) / (H_STEP * scale);
                    const worldY = (clientY - centerY) / (V_STEP * scale);
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    scale *= zoomFactor;
                    scale = Math.max(0.2, Math.min(10, scale));
                    
                    offsetX = clientX - gridCanvas.width/2 - worldX * H_STEP * scale;
                    offsetY = clientY - gridCanvas.height/2 - worldY * V_STEP * scale;
                    
                    drawGrid();
                    drawDrawings();
                }
            }
            
            // === SETUP EVENT LISTENERS ===
            function setupEventListeners() {
                // Mouse events
                drawCanvas.addEventListener('mousedown', handleDragStart);
                drawCanvas.addEventListener('mousemove', handleDragMove);
                drawCanvas.addEventListener('mouseup', handleDragEnd);
                drawCanvas.addEventListener('mouseleave', handleDragEnd);
                
                // Touch events
                drawCanvas.addEventListener('touchstart', handleDragStart);
                drawCanvas.addEventListener('touchmove', handleDragMove);
                drawCanvas.addEventListener('touchend', handleDragEnd);
                drawCanvas.addEventListener('touchcancel', handleDragEnd);
                
                // Zoom events
                drawCanvas.addEventListener('wheel', handleZoom, { passive: false });
                drawCanvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        lastDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                    }
                });
                
                // UI Controls
                document.getElementById('toggle-grid').addEventListener('click', () => {
                    gridEnabled = !gridEnabled;
                    document.getElementById('toggle-grid').textContent = gridEnabled ? '‚¨ü GRID ON' : '‚¨ü GRID OFF';
                    document.getElementById('toggle-grid').className = gridEnabled ? 'active' : '';
                    drawGrid();
                });
                
                document.getElementById('clear-draw').addEventListener('click', () => {
                    drawings = [];
                    drawDrawings();
                });
                
                // Reset with R key
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === 'R') {
                        scale = 1.0;
                        offsetX = 0;
                        offsetY = 0;
                        drawGrid();
                        drawDrawings();
                    }
                });
                
                // Window resize
                window.addEventListener('resize', resizeCanvases);
            }
            
            // === INIT ===
            resizeCanvases();
            setupEventListeners();
            
            // Expose drawings array for external use
            window.hexGrid = {
                addPoint: (worldX, worldY, color = '#ffaa66', size = 8) => {
                    const centerX = gridCanvas.width / 2 + offsetX;
                    const centerY = gridCanvas.height / 2 + offsetY;
                    
                    const screenX = centerX + worldX * scale;
                    const screenY = centerY + worldY * scale;
                    
                    drawings.push({ x: screenX, y: screenY, color, size });
                    drawDrawings();
                },
                clear: () => {
                    drawings = [];
                    drawDrawings();
                },
                gridEnabled: () => gridEnabled,
                setGridEnabled: (enabled) => {
                    gridEnabled = enabled;
                    document.getElementById('toggle-grid').textContent = gridEnabled ? '‚¨ü GRID ON' : '‚¨ü GRID OFF';
                    document.getElementById('toggle-grid').className = gridEnabled ? 'active' : '';
                    drawGrid();
                }
            };
        })();
    </script>
</body>
</html>
