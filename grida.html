<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Purple Triangular Grid - Precision Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace;
            touch-action: none;
        }
        canvas {
            display: block;
            background: #0a0a0a;
            width: 100%;
            height: 100%;
        }
        #coords-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(8px);
            color: #c4b5fd;
            padding: 16px 28px;
            border-radius: 60px;
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 0.5px;
            border: 1px solid #c4b5fd30;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            z-index: 1000;
            pointer-events: none;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            text-shadow: 0 0 10px #c4b5fd40;
            white-space: nowrap;
        }
        #coords-panel span {
            color: #ffffff;
            font-weight: 600;
            margin: 0 4px;
        }
        #status-bar {
            position: fixed;
            top: 24px;
            right: 24px;
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(8px);
            color: #c4b5fd;
            padding: 10px 18px;
            border-radius: 40px;
            font-size: 14px;
            border: 1px solid #c4b5fd30;
            z-index: 1000;
            pointer-events: none;
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            display: flex;
            gap: 16px;
        }
        #zoom-level, #grid-size {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #zoom-level::before {
            content: "üîç";
            opacity: 0.7;
            font-size: 12px;
        }
        #grid-size::before {
            content: "‚¨ü";
            opacity: 0.7;
            font-size: 14px;
        }
        #instruction {
            position: fixed;
            top: 24px;
            left: 24px;
            background: rgba(20, 20, 30, 0.5);
            backdrop-filter: blur(4px);
            color: #c4b5fd80;
            padding: 8px 16px;
            border-radius: 40px;
            font-size: 13px;
            border: 1px solid #c4b5fd20;
            z-index: 1000;
            pointer-events: none;
        }
        @media (max-width: 600px) {
            #coords-panel {
                font-size: 14px;
                padding: 12px 20px;
                bottom: 16px;
            }
            #status-bar {
                top: 16px;
                right: 16px;
                padding: 8px 14px;
                font-size: 12px;
                flex-direction: column;
                gap: 4px;
            }
            #instruction {
                top: 16px;
                left: 16px;
                font-size: 11px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="coords-panel">
        <span id="coord-x">0.00</span> , <span id="coord-y">0.00</span>
    </div>
    
    <div id="status-bar">
        <div id="zoom-level"><span id="zoom-value">1.00</span>x</div>
        <div id="grid-size"><span id="size-value">48</span>px</div>
    </div>
    
    <div id="instruction">
        ‚ö° DRAG ¬∑ PINCH ¬∑ ZOOM ¬∑ R RESET
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid parameters - denser for infinite feel
        const BASE_SIZE = 24; // base triangle side length
        const H_STEP = BASE_SIZE * 2;  // double horizontal step (48px at 1x)
        const V_STEP = BASE_SIZE * Math.sqrt(3); // vertical step (~41.57px at 1x)
        
        // View state
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        
        // Interaction
        let isDragging = false;
        let lastX, lastY;
        let lastDistance = 0;
        
        // Purple theme - single consistent color
        const PURPLE = '#c4b5fd'; // Soft purple
        const PURPLE_DARK = '#a78bfa';
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        
        function snapToGrid(x, y) {
            // Convert screen to world coordinates
            const centerX = canvas.width / 2 + offsetX;
            const centerY = canvas.height / 2 + offsetY;
            
            const scaledH = H_STEP * scale;
            const scaledV = V_STEP * scale;
            
            // Calculate potential grid positions
            const worldX = (x - centerX) / scaledH;
            const worldY = (y - centerY) / scaledV;
            
            // Find nearest intersection point
            const row = Math.round(worldY);
            let col = Math.round(worldX);
            
            // Adjust for staggered rows
            if (row % 2 !== 0) {
                // For odd rows, intersections are offset by half
                const exactX = worldX - 0.5;
                col = Math.round(exactX);
                return {
                    x: (col + 0.5) * H_STEP,
                    y: row * V_STEP,
                    screenX: centerX + (col + 0.5) * scaledH,
                    screenY: centerY + row * scaledV
                };
            } else {
                return {
                    x: col * H_STEP,
                    y: row * V_STEP,
                    screenX: centerX + col * scaledH,
                    screenY: centerY + row * scaledV
                };
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2 + offsetX;
            const centerY = canvas.height / 2 + offsetY;
            
            const scaledH = H_STEP * scale;
            const scaledV = V_STEP * scale;
            
            // Calculate visible range with margin
            const cols = Math.ceil(canvas.width / scaledH) + 8;
            const rows = Math.ceil(canvas.height / scaledV) + 8;
            
            const startCol = -Math.floor(cols / 2) - 2;
            const startRow = -Math.floor(rows / 2) - 2;
            const endCol = startCol + cols + 4;
            const endRow = startRow + rows + 4;
            
            // Update UI
            const worldCenterX = -offsetX / (H_STEP * scale) * H_STEP;
            const worldCenterY = -offsetY / (V_STEP * scale) * V_STEP;
            document.getElementById('coord-x').textContent = worldCenterX.toFixed(2);
            document.getElementById('coord-y').textContent = worldCenterY.toFixed(2);
            document.getElementById('zoom-value').textContent = scale.toFixed(2);
            document.getElementById('size-value').textContent = Math.round(BASE_SIZE * scale);
            
            // HAIRLINE THIN - width adapts to zoom to maintain hairline appearance
            ctx.lineWidth = Math.max(0.5, 1.2 / Math.sqrt(scale));
            
            // All lines same purple color with opacity
            ctx.strokeStyle = PURPLE;
            
            // HORIZONTAL LINES
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            for (let row = startRow; row <= endRow; row++) {
                const y = centerY + row * scaledV;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
            
            // +60¬∞ DIAGONALS
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            for (let row = startRow - 3; row <= endRow + 3; row++) {
                for (let col = startCol - 3; col <= endCol + 3; col++) {
                    const x = centerX + col * scaledH;
                    const y = centerY + row * scaledV;
                    
                    const xOffset = (row % 2 === 0) ? 0 : scaledH / 2;
                    
                    const extend = Math.max(canvas.width, canvas.height) * 1.5;
                    ctx.moveTo(x + xOffset - extend, y - extend * Math.tan(60 * Math.PI / 180));
                    ctx.lineTo(x + xOffset + extend, y + extend * Math.tan(60 * Math.PI / 180));
                }
            }
            ctx.stroke();
            
            // -60¬∞ DIAGONALS
            ctx.beginPath();
            for (let row = startRow - 3; row <= endRow + 3; row++) {
                for (let col = startCol - 3; col <= endCol + 3; col++) {
                    const x = centerX + col * scaledH;
                    const y = centerY + row * scaledV;
                    
                    const xOffset = (row % 2 === 0) ? 0 : scaledH / 2;
                    
                    const extend = Math.max(canvas.width, canvas.height) * 1.5;
                    ctx.moveTo(x + xOffset - extend, y + extend * Math.tan(60 * Math.PI / 180));
                    ctx.lineTo(x + xOffset + extend, y - extend * Math.tan(60 * Math.PI / 180));
                }
            }
            ctx.stroke();
            
            // VERTICES - subtle dots at intersections
            ctx.fillStyle = PURPLE;
            ctx.globalAlpha = 0.4;
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const x = centerX + col * scaledH;
                    const y = centerY + row * scaledV;
                    
                    if (row % 2 !== 0) {
                        ctx.beginPath();
                        ctx.arc(x + scaledH/2, y, 1.5, 0, Math.PI*2);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.arc(x, y, 1.5, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
            
            // ORIGIN MARKER - bright
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI*2);
            ctx.fill();
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
        }
        
        // Handle mouse/touch for coordinate picking
        function handlePointerStart(e) {
            e.preventDefault();
            isDragging = true;
            lastX = e.clientX ?? e.touches[0].clientX;
            lastY = e.clientY ?? e.touches[0].clientY;
            
            // Show snapped coordinate on click/touch
            if (e.type === 'mousedown' || e.type === 'touchstart') {
                const x = e.clientX ?? e.touches[0].clientX;
                const y = e.clientY ?? e.touches[0].clientY;
                const snapped = snapToGrid(x, y);
                
                // Flash the snapped point
                ctx.save();
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(snapped.screenX, snapped.screenY, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
                
                // Update coord display briefly
                document.getElementById('coord-x').textContent = snapped.x.toFixed(2);
                document.getElementById('coord-y').textContent = snapped.y.toFixed(2);
            }
        }
        
        function handlePointerMove(e) {
            e.preventDefault();
            if (!isDragging) return;
            
            const currentX = e.clientX ?? e.touches[0].clientX;
            const currentY = e.clientY ?? e.touches[0].clientY;
            
            offsetX += currentX - lastX;
            offsetY += currentY - lastY;
            
            lastX = currentX;
            lastY = currentY;
            
            draw();
        }
        
        function handlePointerEnd(e) {
            e.preventDefault();
            isDragging = false;
        }
        
        // Zoom with wheel (desktop)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate world position before zoom
            const centerX = canvas.width / 2 + offsetX;
            const centerY = canvas.height / 2 + offsetY;
            
            const worldX = (mouseX - centerX) / (H_STEP * scale);
            const worldY = (mouseY - centerY) / (V_STEP * scale);
            
            // Apply zoom
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            scale *= zoomFactor;
            scale = Math.max(0.15, Math.min(12, scale)); // Wider zoom range
            
            // Adjust offset to zoom toward mouse
            const newCenterX = canvas.width / 2 + offsetX;
            const newCenterY = canvas.height / 2 + offsetY;
            
            offsetX += (mouseX - newCenterX) - worldX * H_STEP * scale;
            offsetY += (mouseY - newCenterY) - worldY * V_STEP * scale;
            
            draw();
        }, { passive: false });
        
        // Pinch zoom for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                lastDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            } else if (e.touches.length === 1) {
                handlePointerStart(e);
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                // Pinch zoom
                const distance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                
                if (lastDistance > 0) {
                    const zoomFactor = distance / lastDistance;
                    const prevScale = scale;
                    scale *= zoomFactor;
                    scale = Math.max(0.15, Math.min(12, scale));
                    
                    // Adjust for center of pinch
                    const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    
                    const rect = canvas.getBoundingClientRect();
                    const centerX = canvas.width / 2 + offsetX;
                    const centerY = canvas.height / 2 + offsetY;
                    
                    const worldX = (midX - rect.left - centerX) / (H_STEP * prevScale);
                    const worldY = (midY - rect.top - centerY) / (V_STEP * prevScale);
                    
                    offsetX = midX - rect.left - canvas.width/2 - worldX * H_STEP * scale;
                    offsetY = midY - rect.top - canvas.height/2 - worldY * V_STEP * scale;
                    
                    draw();
                }
                lastDistance = distance;
            } else if (e.touches.length === 1) {
                handlePointerMove(e);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length < 2) {
                lastDistance = 0;
            }
            if (e.touches.length === 0) {
                handlePointerEnd(e);
            }
        });
        
        // Mouse events
        canvas.addEventListener('mousedown', handlePointerStart);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerEnd);
        canvas.addEventListener('mouseleave', handlePointerEnd);
        
        // Reset with R key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                scale = 1.0;
                offsetX = 0;
                offsetY = 0;
                draw();
            }
        });
        
        // Initialize
        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
